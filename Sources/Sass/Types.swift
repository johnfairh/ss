//
//  Types.swift
//  Sass
//
//  Copyright 2020 swift-sass contributors
//  Licensed under MIT (https://github.com/johnfairh/swift-sass/blob/main/LICENSE
//

import Foundation

// Sass compiler interface types, shared between embedded Sass and libsass.
// Doc comments mostly lifted from Sass docs.

/// Possible ways to format the CSS produced by a Sass compiler.
public enum CssStyle {
    /// Each selector and declaration is written on its own line.
    case expanded

    /// The entire stylesheet is written on a single line, with as few
    /// characters as possible.
    case compressed

    /// CSS rules and declarations are indented to match the nesting of the
    /// Sass source.
    case nested

    /// Each CSS rule is written on its own single line, along with all its
    /// declarations.
    case compact
}

/// Language used for a stylesheet.
public enum Syntax {
    /// The CSS-superset `.scss` syntax.
    case scss

    /// The indented `.sass` syntax.
    case indented, sass

    /// Plain CSS syntax that doesn't support any special Sass features.
    case css
}

/// Results of a successful compilation.
public struct CompilerResults {
    /// The  CSS output from the compiler.
    public let css: String
    /// The JSON sourcemap, provided only if requested at compile time.
    public let sourceMap: String?
    /// Any compiler warnings.
    public let warnings: [CompilerWarning]

    /// :nodoc:
    public init(css: String, sourceMap: String?, warnings: [CompilerWarning]) {
        self.css = css
        self.sourceMap = sourceMap
        self.warnings = warnings
    }
}

/// Error thrown indicating a failed compilation.
public struct CompilerError: Swift.Error {
    /// A message describing the reason for the failure.
    public let message: String

    /// The span if any associated with the failure.
    public let span: Span?

    /// The stylesheet stack trace associated with the failure.
    public let stackTrace: String?

    /// Any compiler warnings found before the error.
    public let warnings: [CompilerWarning]

    /// :nodoc:
    public init(message: String, span: Span?, stackTrace: String?, warnings: [CompilerWarning]) {
        self.message = message
        self.span = span
        self.stackTrace = stackTrace
        self.warnings = warnings
    }
}

/// A section of a file.
public struct Span: CustomStringConvertible {
    /// The text covered by the source span, or `nil` if there is no
    /// source text associated with this report.
    public let text: String?

    /// The URL of the file to which this span refers, or `nil` if it refers to
    /// an inline compilation that doesn't specify a URL.
    /// XXX use `URL` ?
    public let url: String?

    /// A single point in s source file.
    public struct Location: CustomStringConvertible {
        /// The 0-based byte offset of this location within the source file.
        public let offset: Int

        /// The 0-based line number of this location within the source file.
        public let line: Int

        /// The 0-based column number of this location within its line.
        public let column: Int

        /// A short human-readable description of the location.  Uses 1-based counting!
        public var description: String {
            "\(line + 1):\(column + 1)"
        }

        /// :nodoc:
        public init(offset: Int, line: Int, column: Int) {
            self.offset = offset
            self.line = line
            self.column = column
        }
    }

    /// The location of the first character in this span.
    public let start: Location

    /// The location of the first character after this span, or `nil` to mean
    /// this span is zero-length and points just before `start`.
    public let end: Location?

    /// Additional source text surrounding this span.
    ///
    /// This usually contains the full lines the span begins and ends on if the
    /// span itself doesn't cover the full lines.
    public let context: String?

    /// A short human-readable description of the span.
    public var description: String {
        var desc = url.flatMap { URL(string: $0)?.lastPathComponent } ?? "[input]"
        desc.append(" \(start)")
        if let end = end {
            desc.append("-\(end)")
        }
        return desc
    }

    /// :nodoc:
    public init(text: String?, url: String?, start: Location, end: Location?, context: String?) {
        self.text = text
        self.url = url
        self.start = start
        self.end = end
        self.context = context
    }
}

/// A message generated by the compiler during compilation that does not prevent a
/// successful result.  Appropriate for display to end users that own the stylesheets.
public struct CompilerWarning {
    /// Kinds of messages generated during compilation that do not prevent a successful result.
    public enum Kind {
        /// A warning for something other than a deprecated Sass feature. Often
        /// emitted due to a stylesheet using the `@warn` rule.
        case warning

        /// A warning indicating that the stylesheet is using a deprecated Sass
        /// feature. The accompanying text does include text like "deprecation warning".
        case deprecation
    }

    /// Kind of the message.
    public let kind: Kind

    /// Text of the message, english.
    public let message: String

    /// Optionally a description of the source that triggered the warning.
    public let span: Span?

    /// The stack trace through the compiler input source files leading to the
    /// point of the warning.
    public let stackTrace: String?

    /// : nodoc:
    public init(kind: Kind, message: String, span: Span?, stackTrace: String?) {
        self.kind = kind
        self.message = message
        self.span = span
        self.stackTrace = stackTrace
    }
}

/// A log message generated by the system.  May help with debug.
/// Not for end users. XXX review compilationID here.
public struct DebugMessage {
    /// Text of the message, english.
    public let message: String

    /// Optionally a description of the source that triggered the log.
    public let span: Span?

    /// Initialize a new message. :nodoc:
    public init(_ message: String, span: Span? = nil) {
        self.message = message
        self.span = span
    }
}

/// A routine to receive log events during compilation.
public typealias DebugHandler = (DebugMessage) -> Void

// MARK: Message pretty-printers

/// Gadget to share implementation between the subtly different error/warning/debug log types.
protocol LogFormatter {
    var message: String { get }
    var messageType: String? { get }
    var span: Span? { get }
    var stackTrace: String? { get }
    var description: String { get }
}

extension LogFormatter {
    var messageType: String? { nil }

    var baseDescription: String {
        var desc = span.flatMap { "\($0): " } ?? ""
        desc += messageType.flatMap { "\($0): " } ?? ""
        desc += message
        if let trace = stackTrace?.trimmingCharacters(in: .newlines),
           !trace.isEmpty {
            let paddedTrace = trace.split(separator: "\n")
                .map { "    " + $0 }
                .joined(separator: "\n")
            desc += "\n\(paddedTrace)"
        }
        return desc
    }

    public var description: String {
        baseDescription
    }
}

extension CompilerError: CustomStringConvertible, LogFormatter {
    var messageType: String? { "error" }

    /// A  human-readable description of the message.
    public var description: String {
        warnings.map { "\($0.description)\n" }.joined() + baseDescription
    }
}

extension CompilerWarning.Kind: CustomStringConvertible {
    /// A human-readable description of the warning type.
    public var description: String {
        switch self {
        case .deprecation: return "deprecation warning"
        case .warning: return "warning"
        }
    }
}

extension CompilerWarning: CustomStringConvertible, LogFormatter {
    var messageType: String? { kind.description }
}

extension DebugMessage: CustomStringConvertible, LogFormatter {
    var stackTrace: String? { nil }
}
